# 8章 巨大な式を分割する *Breaking Down Giant Expressions*
巨大な式は飲み込みやすい大きさに分割する。最近の研究では、人間は一度に3～4のものしか考えられないそうだ。つまり、コードの式が大きくなれば、それだけ理解が難しくなるのである。

### 8.1 説明変数 *Explaining Variables*
式を簡単に分割するには、式を表す変数を使えばいい。この変数を説明変数と呼ぶこともある。

### 8.2 要約変数 *Summary Variables*
式を説明する必要がない場合でも式を変数に代入しておくと便利だ。大きなコードの塊を小さな名前に置き換えて、監理や把握を簡単にする変数のことをようやく変数と呼ぶ。

### 8.3 ド・モルガンの法則を使う *Use De Morgan's Laws*
1) not (a or b or c)    ⇔ (not a) and (not b) and (not c)
2) not (a and b and c ) ⇔ (not a) or (not b) or (not c)

この式が覚えにくいようであれば、「not を分配して and/or を反転する」と覚えればいい。

### 8.4 短絡評価の悪用 *Abusing Short-Circuit Logic*
ブール演算子は短絡評価を行うものが多い。すごく便利だけど、悪用すると複雑なロジックになってしまう。

以下は、著者のひとりが過去に書いた（C++の）コードの例だ。

```
assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());
```

これは「このキーのバケツを取得する。もしバケツが null じゃなかったら、中身が入っていないかを確認する」という意味だ。まったく同じものだけど、以下のほうがずっと理解しやすくなった。

```
bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket->IsOccupied());
```

どうして1行で書こうとしたのだろう？ そのときは「オレは頭がいい」と思っていたのだ。ロジックを簡潔なコードに落とし込むことに一種の喜びを感じていた。この気持ちがみんなにも理解してもらえると思う。問題は、これがコードのスピードバンプになっていたことだ。

他にも言っておきたいイディオムがある。Python・JavaScript・Ruby・Kotlin などの言語では、複数の引数のなかから1つを返すOR演算子が使える。

### 8.5 例：複雑なロジックと格闘する *Example: Wrestling with Complicated Logic*
（左閉右開区間を示す）Range クラスを実装しているとしよう。

![range](https://github.com/MxShun/readable-code-with-kotlin/blob/main/Chapter08_Breaking-Down-Giant-Expressions/src/main/resources/range.png "Range")

区間内の条件分けを実装していくと、場合分けや条件が多すぎてバグを見逃しやすい。解決策を見つけるには創造性が必要だ。でも、どうすればいいのだろう？ 反対から問題を解決してみるという手法がある。 今回の場合、反対を考えると重ならない部分になる。2つの範囲が重ならないのは簡単だ。2つの場合しかない。

1) 一方の範囲の終端が、ある範囲の始点よりも前にある場合
2) 一方の範囲の始点が、ある範囲の終点よりも後にある場合

このような視点の切り替えにより、コードがずっと単純になる。

### 8.6 巨大な式を分割する *Breaking Down Giant Statements*
巨大な分があった場合、同じ式を抽出して要約変数として関数の最上部に抽出すればいい（これは DRY 原則の実例でもある）。

これにより、以下のようなことが副産物的に得られることがある。

- タイプミスを減らすのに役立つ
- 横幅が縮まることでコードが読みやすくなる

### 8.7 式を簡潔にするもう1つの創造的な方法 *Another Creative Way to Simplify Expressions*
同じような式が複数ある場合、関数として定義すればいい。何も関数を頻繁に使えと言ってるわけじゃない。コードがわかりにくくなるし、見つけにくいバグがもぐりこんでしまうこともある。でも、簡潔で読みやすくなるという明確な利点がもたらされる場合もある。
