# 15章 「分/時間カウンタ」を設計・実装する *Designing and Implementing a "Minute/Hour Counter"*
本物のプロダクトコードで使われているデータ構造「分/時間カウンタ」を見ていこう。問題を解決して、パフォーマンスを改善して、機能を追加する。このようなエンジニアの自然な思考プロセスをたどることにしよう。でも、一番大切なのは、本書の原則を使ってコードを読みやすくすることだ。

### 15.1 問題点 *The Problem*
ウェブサーバの直近 1 分間と直近 1 時間の転生バイト数を把握したい。

素朴な問題だ。でも、これを効率的に解決するのは簡単ではなさそうだ。

### 15.2 クラスのインタフェースを定義する *Defining the Class Interface*

```
abstract class MinutesHourCounter {
    // カウンタを追加する
    abstract fun count(numBytes: Int)

    // 直近 1 分間のカウンタを返す
    abstract fun minuteCount(): Int

    // 直近 1 時間のカウントを返す
    abstract fun hourCount(): Int
}
```

#### 名前を改善する *Improving the Name*
count() というメソッド名には問題がある。

ぼくたちは同僚に「count() は何をすると思う？」と聞いてみた。すると「全期間のカウントを返す」と答えた人が何人もいた。つまり、この名前は直観的ではないのだ。count に名詞と動詞があるのが問題なのだろう。

count() の代わりになりそうなものを挙げよう。

- increment() 値が増加する一方だと思われてしまう。 
- observe() 問題はない。でも少し曖昧だ。 
- record() 名詞と動詞の問題があるのでダメだ。 
- add() 興味深い。

また、MinuteHourCounter クラスが仮引数の「バイト数」を知る必要はない。

```
abstract class MinutesHourCounter {
    // カウンタを追加する
    abstract fun add(count: Int)
    
    // 直近 1 分間のカウンタを返す
    abstract fun minuteCount(): Int
    
    // 直近 1 時間のカウントを返す
    abstract fun hourCount(): Int
}
```

#### コメントを改善する *Improving the Comments*
add() のコメントは冗長だ。削除するか改善すべきだ。

minuteCount() のコメントの意味を同僚に聞いてみたところ、2 種類の答えが返ってきた。

1) 「午後 12:13 のような現在時刻の分数のカウントを返す。
2) 時刻の分数に関係なく「直近 60 秒間のカウント」を返す。

2 つ目の解釈が実際の動作である。より正確で詳細な言葉を使って、誤解のない明確なものにしよう。

```
// 直近 1 分間および直近 1 時間の累積カウントを記録する。
// 例えば、帯域幅の使用状況を確認するのに使える。
abstract class MinutesHourCounter3 {
    // 新しいデータ点を追加する（count >= 0）
    // それから 1 分間は、minuteCount() の返す値が +count だけ増える。
    // それから 1 時間は、minuteHour() の返す値が +count だけ増える。
    abstract fun add(count: Int)
    
    // 直近 60 秒間の累積カウントを返す
    abstract fun minuteCount(): Int

    // 直近 3660 秒間の累積カウントを返す
    abstract fun hourCount(): Int
}
```

### 15.3 試案1: 素朴な解決策 *Attempt 1: A Native Solution*
#### このコードは理解しやすいか？ *Is the Code Easy to Understand?*
この解決策は「正しい」けれど、読みにくい点がいくつかある。

- while ループが少しうるさい。―― この部分を読むときに速度が著しく落ちる。（もちろんバグがないことを確かめるには速度を落とす必要がある。）
- minuteCount() と hourCount() がほぼ同じ。―― 重複コードを共通化すればコードをちいさくできる。ここは比較的複雑なところなので、特に共有化した方がいい（複雑なコードは一か所にまとめるべきだ）。 

#### 読みやすいバージョン *An Easier-to-Read Version*
minuteCount() と hourCount() のコードは数値が違うだけだ。両方を処理するヘルパーメソッドを導入して、リファクタリングするのがいいだろう。

```
class MinutesHourCounter5 {
    private val events = arrayListOf<Event>()
    // 新しいデータ点を追加する（count >= 0）
    // それから 1 分間は、minuteCount() の返す値が +count だけ増える。
    // それから 1 時間は、minuteHour() の返す値が +count だけ増える。
    fun add(count: Int) {
        events.add(
            Event(
                count = 0,
                time = Instant.now()
            )
        )
    }

    // 直近 60 秒間の累積カウントを返す
    fun minuteCount(): Int {
        return countSince(Duration.ofSeconds(Instant.now().epochSecond - 60))
    }

    // 直近 3660 秒間の累積カウントを返す
    fun hourCount(): Int {
        return countSince(Duration.ofSeconds(Instant.now().epochSecond - 3600))
    }

    private fun countSince(cutoff: Duration): Int {
        var count = 0
        val rit = events.reversed().iterator()
        while (rit.hasNext()) {
            if (rit.next().time.epochSecond <= cutoff.seconds) {
                break
            }
            count += rit.next().count
        }
        return count
    }
}
```

この新しいコードには、注目すべき点がいくつかある。

まず、countSince() の仮引数の名前を *secsAgo* という相対値ではなく、 *cutoff* という絶対値にしている。動作がかわるわけではないけど、名前を変えた方が countSince() が扱いやすくなる。

次に、イテレータの名前を *i* から *rit* に変えている。*i* はインデックスによく使われる名前なので、ぼくたちも最初はこの名前を使おうと思っていた。でも、ここで使っているのは逆向きのイテレータだ。このコードを正しく動かすには欠かせない部分である。

最後に、while ループから *rit.next().time.epochSecond <= cutoff.seconds* という条件を抽出して、新しく if 文を作っている。これはなぜだろうか？ こうすれば「すべての要素を調べる」ことがすぐにわかるし、それ以上深く考える必要がなくなる。

#### パフォーマンスの問題 *Performance Problems*
これまでのコードの見た目を中心に改善してきたけど、この設計には深刻なパフォーマンスの問題がある。

1) これからも大きくなっていく。このクラスはすべてのイベントを保持している。つまり、メモリを無限に使用してしまうのだ！ MinuteHourCounter は、1 時間よりも古い不要なイベントを自動的に削除するべきだ。
2) minuteCount() と hourCount() が遅すぎる。countSince() メソッドの処理時間は *O(n)* である。*n* は任意の時間帯のデータ点の数だ。高性能のサーバが、add() を 1 秒間に何百回呼び出したらどうなるだろうか。hourCount() を呼び出すたびに、数百万個のデータ点をカウントしなければいけなくなるのだ！ MinuteHourCounter は、add() の呼出しに対応する値を minuteCount と hourCount とで別々に保持すべきだ。

### 15.4 試案2: ベルトコンベヤー設計 *Attempt 2: Conveyor Belt Design*
さきほどの問題を両方解決する設計が必要だ。

1) 不要なデータを削除する。
2) 事前に minuteCount と hourCount の値を最新のものにしておく。

これからやることを説明しておこう。List をベルトコンベヤーのように使うのだ。一方の端に新しいデータが到着したら合計に加算する。データが古すぎたらもう一方の端から「落下」させて合計から減算する。

ベルトコンベヤー設計の実装は 2 種類ある。

1 つ目は、2 つの List を管理する方法だ。1 つは直近 1 分間のイベントに、もう 1 つは直近 1 時間のイベントに使う。新しいイベントが到着したら両方にコピーを追加する。この方法はすごく単純だけど、すべてのイベントを 2 つずつ作るので非効率だ。

2 つ目も、2 つの List を管理する方法だ。ただし、1 番目の List にイベントが到着してから、2 番目の List に流れ込むようになっている。2 つ目の「二段階」ベルトコンベヤー設計の方が効率的なので、こちらを実装することにしよう。

#### 二段階ベルトコンベヤーの実装 *Implementing the Two-Stage Conveyor Belt Design*
#### これで終わり？ *Are We Done?*
これで 2 つのパフォーマンス問題が解決できた。この解決策で問題ない。多くのアプリケーションではこれで十分だろう。ただし、欠点がたくさんある。

まず、この設計には柔軟性がない。例えば、直近 24 時間のカウントを保存したいとする。すると、多くのコードに修正が必要になる。

次に、メモリの使用量が多い。高トラフィックのサーバが 1 秒間に 100 回も add() を呼び出したとしよう。直近 1 時間のデータをすべて保持しているので、約 5MB のメモリが必要になる。

add() が頻繁に呼び出されると、それだけメモリを多く消費してしまう。プロダクション環境では、予測不能な量のメモリを使うライブラリはよしとされていない。add() が呼び出される頻度に関係なく、MinuteHourCounter の使用するメモリは一定である方がいい。

### 15.5 試案3: 時間バケツの設計 *Attempt 3: A Time-Bucketed Design*
気づいていないかもしれないけど、先ほどの 2 つの実装にはどちらも小さなバグがあった。タイムスタンプを保持するのに使ったクラスは秒数を保持しているので、ここで数値が丸められてしまう。その結果、minuteCount() は呼び出された時刻によって、59 秒か 60 秒のデータを返すことになる。

ミリ秒の粒度を使えばこの問題はすべて解決できる。でも、MinuteHourCounter を使っているアプリケーションでは、このレベルの精度を必要としない。というわけで、このことを踏まえて、高速でメモリ使用量も少ない新しい MinuteHourCounter を設計した。パフォーマンスと精度はトレードオフなのだ。

イベントを小さな時間帯に分けてバケツに入れ、バケツ単位でイベントの合計値を出すというのが鍵となる考えだ。例えば、直近 1 分間のイベントは、1 秒ごとに 60 個のバケツに入れる。直近 1 時間のイベントは、1 分ごとに 60 個のバケツに入れる。

このようなバケツを使えば、minuteCount() や hourCount() のメソッドは 1/60 の精度になる。

もっと正確なものが必要であれば、メモリ使用量と引き換えにバケツの数を増やすことができる。でも、ここで一番大切なのは、個の設計にすればメモリ使用量を固定化できて予測可能になるということだ。

#### 時間バケツの実装 *Implementing the Time-Bucketed Design*
この設計をクラス 1 つで実装すると、理解できない複雑なコードになる。「11 章 一度に 1 つのことを」のアドバイスにしたがって、複数のクラスで異なる部分を処理していきたい。これにより、コードは読みやすくなり、柔軟性も高くなった。

#### TrailingBucketCounter を実現する *Implementing TrailingBucketCounter*

#### ConveyorQueue の実装 *Implementing ConveyorQueue*

### 15.6 3 つの解決策を比較する *Comparing the Three Solutions* 
本章で取り上げた解決策を比較しよう。

| 解決策 | コードの行数 | HourCount() の計算量 | メモリ使用量 | HourCount() の誤差 |
| --- | --- | --- | --- | --- |
| 素朴な解決策 | 33 | *O(1時間のイベント数)*（～360万） | 制限なし | 1/3600 |
| ベルトコンベヤー設計 | 55 | *O(1)* | *O(1時間のイベント数)*（～5MB） | 1/3600 |
| 時間バケツ設計（バケツ 60 個） | 98 | *O(1)* | *O(バケツの数)*（～500バイト） | 1/60 |

3 つのクラスを使うことになった時間バケツのコード行数は、他 2 つのコード行数よりもずっと多い。でも、パフォーマンスは高石、設計に柔軟性がある。それに、クラスに分割しているので読みやすい。50 行の読みにくいコードよりも、100 行の読みやすいコードの方が優れているのだ。

問題を複数のクラスに分割すると、複数のクラスになったことが原因で複雑になることもある。今回はクラスが「線形」につながっていて、ユーザに公開されているクラスは 1 つだけになっている。したがって、問題を分割することで、利点だけが得られるようになっている。

### 15.7 まとめ *Summary*
最終的に MinuteHourCounter になるまでの手順をおさらいしよう。コードの進化の様子がうまく表されている。

まずは、素朴な解決策から始めた。ここから設計上の課題が 2 つあることが分かった。速度とメモリ使用量である。

次に、「ベルトコンベヤー」設計を試した。個の設計は速度とメモリ使用量の問題は改善できたけど、高パフォーマンスのアプリケーションには適していなかった。また、柔軟性が乏しく、その他の時間帯を扱うにはかなり手を入れる必要があった。

最終的な設計では、複数の下位問題に分割することで、これらの問題を解決した。ボトムアップで 3 つのクラスを作り、それぞれのクラスで各下位問題を解決するようにした。

- ConveyorQueue 最大長であるキュー。「シフト」可能で合計値を保持する。
- TrailingBucketCounter 時間経過に伴って ConveyorQueue を移動する。また、1 つの時間帯のカウンタを任意の精度で保持する。
- MinuteHourCounter 2 つの TrailingBucketCounter を保持する。1 つは 1 分間のカウントで、もう 1 つは 1 時間のカウントだ。
