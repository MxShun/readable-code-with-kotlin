# 7章 制御フローを読みやすくする *Making Control Flow Easy to Read*
条件やループなどの制御フローはできるだけ自然にする。コードの読み手が立ち止まったり読み返したりしないように書く。

### 7.1 条件式の引数の並び方 *The Order of Arguments in Conditionals*
- 左辺：調査対象の式。変化する。
- 右辺：比較対象の式。あまり変化しない。

この指針は英語の用法と合っている。英語で「もし君が18歳以上ならば」と言うのは自然だ。「もし18年が金の年齢以下ならば」と言うのは不自然だ。

今もヨーダ記法は便利なのか？上の指針で言えば、順序を逆にするとコードが不自然で読みにくくなる。「ヨーダ記法」は過去のものになりつつあると言えるだろう。

### 7.2 if/else ブロックの並び順 *The Order of if/else Blocks*
if/else 文のブロックには優劣がある。

- 条件は否定形よりも肯定系を使う
- 単純な条件を先に書く
- 感心を引く条件や目立つ条件を先に書く

### 7.3 三項演算子 *The ?: Conditional Expression (a.k.a. "Ternary Operator")*
読みやすさの点から言うと、これには議論の余地がある。支持者は複数行が1行でまとまるのでいいと言う。反対者は、読みにくいしデバッガでステップ実行するのが難しいと言う。

行数を短くするよりも、他の人が理解するのにかかる時間を短くする。

※ Kotlin に三項演算子はない。 if/else 文が式として扱われるため、 if/else の結果を変数に代入するようなことは可能。

### 7.4. do/while ループを避ける *Avoid do/while Loops*
do/while ループが変わっているのは、コードブロックを再実行する条件が下にあることだ。if文・while文・for文などの条件は、コードブロックの上にある。コードは上から下に読んでいくので、do/while 文は少し不自然だ。コードを2回読むことになってしまう。

C++の作者であるビャーネ・ストロヴストルップは、著書「C++ Programming Language」でこう言っている。

> 私の経験では、do-statementは、エラーや混乱の原因になることが多い。（中略）私は条件が「前もって」書かれている方が好きだ。そのため、私は do-statement を割けることが多い。

### 7.5 関数から早く返す *Returning Early from a Function*
関数から早く返すことはいいことだ。

関数の出口を1つにしたいというのは、何らかのクリーンアップコードを確実に実行したいからだろう。現代の言語では、こうした仕組みがより洗練された形で提供されている。

| 言語 | クリーンアップコードのイディオム |
| C++ | デストラクタ |
| Java・Python・Kotlin| try ... finally |
| Python | with |
| C# | using |

### 7.6 悪名高きgoto *The Infamous goto*
goto を使うとすぐに手に負えなくなったり、子^度についていくのが難しくなったリスので、すごく評判が悪い。

神への冒涜だと goto をはねつけるよりも、goto を使うべき理由を分析する方がいいだろう。最も単純で害のない goto というのは、関数の最下部に置いた exit と一緒に使うものだ。

```
    if(p == NULL) goto exit;
    ...

exit:
    fclose(file);
    ...
    return;
```

goto が唯一許されるのがこれだ。これなら goto は大した問題にならない。でも、goto の飛び先きが複数になると問題だ。経路が交差していたらなおさらである。

### 7.7 ネストを浅くする *How Nesting Accumulates*
ネストの深いコードは理解しにくい。ネストが深くなると、読み手は精神的スタックに条件をプッシュしなければいけない。閉じ括弧 } を見てスタックからポップしようと思っても、その条件が何だったのかうまく思い出せない。

### 7.8 実行の流れを追えるかい？ *Can You Follow the Flow of Execution?*
できることならプログラムのすべての実行パスを簡単に追えるようになるといい。main() から出発して、心の中でコードを追っていく。関数を次々に呼び出していく。それをプログラムが終了するまで続けるのだ。

ただし、プログラミング言語やライブラリには、コードを舞台裏で実行する構成要素がある。

| 構成要素 | 高レベルの流れが不明瞭になる理由 |
| スレッド | どのコードがいつ実行されるのかよく分からない |
| シグナル/割り込みハンドラ | 他のコードが実行される可能性がある |
| 例外 | いろんな関数呼び出しが終了しようとする |
| 関数ポインタと無名関数 | コンパイル時に判別できないので、どのコードが実行されるのか分からない |
| 仮想メソッド | object.virtualMethod() は未知のサブクラスのコードを呼び出す可能性がある |

これらの構成要素を使うことで、コードが読みやすくなったり、冗長性が低くなったりすることもある。コード全体に締める割合を大きくしすぎないことが大切だ。こうした構成要素はうまく使わないと、コードの行方を見失ってしまう。
