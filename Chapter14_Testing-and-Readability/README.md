# 14章 テストと読みやすさ *Testing and Readability*
本章では、スッキリと効果的なテストを書くための簡単な技法を教えよう。

テストというのは人によって意味が違う。本章における「テスト」とは、他のコードの振る舞いを確認するためのすべてのコードのことだ。

### 14.1 テストを読みやすくて保守しやすいものにする *Make Tests Easy to Read and Maintain*
テストコードを読みやすくするのは、テスト以外のコードを読みやすくするのと同じくらい大切なことだ。テストコードというのは「本物のコードの動作と使い方を示した非公式的な文書」だと考えるプログラマもいるほどである。テストが読みやすければ、本物のコードの動作が理解しやすくなる。

テストコードが大きくて恐ろしいものだとしたら、以下のようなことが起きる。

- 本物のコードを修正するのを恐れる。 ―― 「うへえ。このコードには手を出したくないなあ。テストを変更するなんて悪夢だよ。」
- 新しいコードを書いたときにテストを追加しなくなる。 ―― テストのあるモジュールが減っていく。そして、コードが正しく動いているのか自身が持てなくなる。

コードのユーザ（特に自分！）には、テストコードを安心して使ってもらいたい。テストコードを変更したことで既存のテストが壊れたとしても、簡単に原因を突き止められるようにしておきたい。そうすれば、安心してテストを追加できるようになる。

### 14.2 このテストのどこがダメなの？ *What's Wrong with This Test?*

```
// × 少なくとも 8 つ問題がある
@Test
fun test1() {
    var docs = listOf<ScoredDocument>()
    docs[0].url = "http://example.com"
    docs[0].score = -5.0
    docs[1].url = "http://example.com"
    docs[1].score = 1.0
    docs[2].url = "http://example.com"
    docs[2].score = 4.0
    docs[3].url = "http://example.com"
    docs[3].score = -99998.7
    docs[4].url = "http://example.com"
    docs[4].score = 3.0

    docs = sortAndFilterDocs(docs = docs)

    assert(docs.size == 3)
    assert(docs[0].score == 4.0)
    assert(docs[1].score == 3.0)
    assert(docs[2].score == 1.0)
}
```


### 14.3 テストを読みやすくする *Making This Test More Readable*
一般的な設計原則として「**大切ではない詳細はユーザから隠し、大切な詳細は目立つようにする**」べきだ。

前節のテストコードは、明らかにこの原則を破っている。これをキレイにするには、最初にヘルパー関数を作る。

#### 最小のテストを作る *Creating the Minimal Test Statement*

さらに改善するには、「12章 コードに思いを込める」の技法を使おう。このテストが何をしようとしているのかを簡単な言葉で説明するのだ。

> 文書のスコアは [-5, 1, 4, -99998.7, 3] である。
> sortAndFilterDocs() を呼び出したあとのスコアは [4, 3, 1] である。
> スコアはこの順番でなければいけない。

いちばん大切なのはスコアの配列なのだ。テストの本質というのは、「こういう状況と入力から、こういう振る舞いと出力を期待する。」のレベルまで要約できる。コードを簡潔に読みやすくするだけでなく、テストステートメントを短くすることで、テストケースの追加が簡単になる。

#### 独自の「ミニ言語」を実装する *Implementing Custom "Minilanguages"*
独自の見に言語を定義すれば、小さな領域で多くの情報を表現できる。

### 14.4 エラーメッセージを読みやすくする *Making Error Messages Readable*
#### もっといい assert() を使う *Using Better Versions of assert()*
多くの言語やライブラリには、洗練された assert() が用意されている。もし使えるのであれば。便利なアサーションメソッドを使うべきだ。テストが失敗するたびに役に立つ。

#### 手作りのエラーメッセージ *Hand-Crafted Error Messages*
既存でいいエラーメッセージが得られなければ、自分で書けばいい！ この話の教訓は、「エラーメッセージはできるだけ役に立つようにする」だ。もしかすると、自分好みのエラーメッセージを印字する「手作りアサート」を用意するのが最善の道かもしれない。

### 14.5 テストの適切な入力値を選択する *Choosing Good Test Inputs*
テストの適切な入力値を選択するには優れた技能が必要だ。 どうすれば適切な入力値を選択できるのだろう？ 適切な入力値というのは、コードを完全にテストするものでなければいけない。それに簡単に読めるような単純なものでなければいけない。

#### 入力値を単純化する *Simplifying the Input Values*
テストには最もキレイで単純な値を選ぶ。

#### 1 つの機能に複数のテスト *Multiple Tests of Functionality*
コードを検証する「完璧」な入力値を 1 つ作るのではなく、小さなテストを複数作る方が、簡単で、効果的で、読みやすい。

丁寧にやりたければ、テストを増やすこともできる。テストケースが分割されていれば、次の人がコードを扱いやすくなる。意図せずにバグを発生させたとしても、失敗したテストによってその場所がわかる。

### 14.6 テストの機能に名前をつける *Naming Test Functions*
テストコードは関数になっていることが多い。関数はテストするメソッドや状況でひとまとめにする。

テスト関数に名前をつけるのは、退屈で無駄なことだと思うかもしれない。でも、 test1() や test2() のような意味のない名前をつけてはいけない。テストの内容を表した名前をつけるべきだ。

- テストするクラス（もしあれば）
- テストする関数
- テストする状況やバグ

長くて変な名前にならないかと怖がることはない。他のコードから呼び出されるものではないので、長くなっても構わない。テスト関数の名前はコメントだと思えばいい。ほとんどのテスティングフレームワークでは、テストが失敗したらその関数の名前が印字されるようになっている。だから、名前は説明的なほうが役に立つのである。

### 14.7 このテストのどこがダメだったのか？ *What Was Wrong with That Test?*

```
// × 少なくとも 8 つ問題がある
@Test
fun test1() {
    var docs = listOf<ScoredDocument>()
    docs[0].url = "http://example.com"
    docs[0].score = -5.0
    docs[1].url = "http://example.com"
    docs[1].score = 1.0
    docs[2].url = "http://example.com"
    docs[2].score = 4.0
    docs[3].url = "http://example.com"
    docs[3].score = -99998.7
    docs[4].url = "http://example.com"
    docs[4].score = 3.0

    docs = sortAndFilterDocs(docs = docs)

    assert(docs.size == 3)
    assert(docs[0].score == 4.0)
    assert(docs[1].score == 3.0)
    assert(docs[2].score == 1.0)
}
```

1) このテストには、どうでもいいことがたくさん書かれている。テストが何をしているかは 1 つの文で記述できる。テストステートメントはあまり長くしてはいけない。
2) テストが簡単に追加できない。思わずコピペしてしまいそうになる。そうなれば、長くて重複の多いコードになってしまう。
3) 失敗メッセージが役に立たない。このテストが失敗すると、「*Assertion failed*」と表示されるだけだ。デバッグに使える情報が足りない。
4) 一度にすべてのことをテストしようとしている。ここではマイナスのフィルタリングとソートの機能のテストだ。テストは分割した方が読みやすい。
5) テストの入力値が単純ではない。 -99998.7 は「大音量」で目立つけど、これといって意味はない。もっと単純なマイナス値で十分である。
6) テストの入力値が不完全である。例えば、スコアが 0 の文書をテストしていない（この文書はフィルタリングされるのか？ されないのか？）。
7) 極端な入力値を使ってテストしていない。例えば、空の入力値・巨大な入力値・重複した入力値など。
8) test1() といういみのない名前がついている。テスト関数の名前は、テストする関数や状況を表したものにすべきだ。

### 14.8 テストに優しい開発 *Test-Friendly Development*
コードにはテストしやすいものとそうでないものがある。テストしやすいこーどには、明確なインタフェースがある。状態の「セットアップ」がない。検証するデータが隠されていない。

プログラムをクラスやメソッドに分割するということは、疎結合にした方がテストしやすいからである。プログラムが密結合していて、クラス間でメソッド呼び出しがたくさん行われていて、メソッド呼び出しに多くの引数が必要だったらどうだろう。プログラムがりかいしにくいだけでなく、テストコードも汚くて読み書きしにくいものになっているはずだ。

テスト容易性の低いコードの特性とそこから生じる設計の問題

| 特性 | テスト容易性の問題 | 設計の問題 |
| --- | --- | --- |
| グローバル変数を使っている。 | グローバルの状態をテストごとに変数化する必要がある。 | どの関数にどんな副作用があるのかわかりにくい。関数を個別に考えることができない。すべてが動くことを理解するにはプログラム全体を把握しなければいけない。 |
| 多くの外部コンポーネントに依存している。 | 最初に足場を設定しなければいけないので、テストを書くのが難しい。テストを書くのが楽しくないので、みんなテストを書こうとしなくなる。 | 依存しているものが落ちるとシステムが使えなくなる。任意の変更にどんな影響があるのかを理解するのが難しい。クラスのリファクタリングが難しい。システムが考えなければいけない故障状態や回復経路が増える。 |
| コードが非決定的な動作をする。 | テストは当てにならず、信頼できない。テストが正常に動かないことがあるので、最終的に無視されるようになる。 | プログラムが競合状態になったり、再現不可能なバグが発生したりする。プラグラムを論理的に判断できなくなる。バグを追跡したり修正したりするのが非常に難しい。 |

テスト容易性の高いコードの特性とそこから生じる設計の利点

| 特性 | テスト容易性の問題 | 設計の問題 |
| --- | --- | --- |
| クラスが小さい。あるいは内部状態を持たない。 | テストしやすい。メソッドをテストするのにセットアップがあまり必要にならない。検査する状態が隠されていない。 | 状態の少ないクラスは単純で理解しやすい。 |
| クラスや関数が 1 つのことをしている。 | 完全にテストするためにテストケースが少なくて済む。 | 小さくて単純なコンポーネントシステムがモジュール化されている。システムは疎結合である。 |
| クラスは他のクラスにあまり依存していない。高度に疎結合かされている。 | 各クラスは独立してテストできる。 | システムは並列的に開発できる。クラスは他の部分を気にすることなく簡単に修正や削除ができる。 |
| 関数は単純でインタフェースが明確である。 | 明確な動作をテストできる。単純なインタフェースなのでテストが楽。 | インタフェースがわかりやすくて再利用しやすい。 |

### 14.9 やるすぎ *Going Too Far*
場合によってはテストに集中しすぎてしまう可能性もある。

- テストのための本物のコードの読みやすさを犠牲にしてしまう。―― 本物のコードをテストしやすいように設計するには、両社に利点がなければいけない。本物のコードは単純で疎結合なものにする。テストは読み書きしやすくする。テストをしやすくするために、本物のコードにゴミを入れてはいけない。
- テストのカバレッジを 100% にしないと気が済まない。―― コードの 90% をテストする方が、残りの 10% をテストするよりも楽である。最後の 10% にはユーザインタフェースやどうでもいいエラーケースが含まれている。その部分はバグのコストが高くないので、テストが割に合わない。現実的には、カバレッジが 100% になることはない。もしも 100% になっているのだとしたら、バグを見逃しているか、機能を実装していないか、仕様が変更されたことに気づいていないかのどれかだ。バグのコストによって、テストコードにかける最適な時間は違ってくる。ウェブサイトのプロトタイプを作っているのであれば、テストは価格なくも問題ない。でも、宇宙船の制御装置や医療機器を作っているのであれば、テストに集中しなければいけないだろう。
- テストがプロダクト開発の邪魔になる。―― プロジェクトの一部にすぎないテストが、プロジェクト全体を支配している状況を目にしたことがある。テストが触れてはいけない神のようになっているのだ。プラグラマたちは、貴重なエンジニアリングの時間を犠牲にしていると知りながら、ある種の儀式としてテストを行っているのである。

### 14.10 まとめ *Summary*
テストコードでも読みやすさが大切だ。テストが読みやすければ、テストが書きやすくなり、みんながテストを追加しやすくなる。また、本物のコードをテストしやすく設計すれば、コードの設計が全体的に改善できる。

テストを改善する点をまとめよう。特に、新しいテストの追加や修正を簡単にすることが大切だ。

- テストのトップレベルはできるだけ簡潔にする。入出力のテストはコード 1 行で記述できるといい。
- テストが失敗したらバグの発見や修正がしやすいようなエラーメッセージを表示する。
- テストに有効な最も単純な入力値を使う。
- テスト関数に説明的な名前を付けて、何をテストしているのかを明らかにする。
