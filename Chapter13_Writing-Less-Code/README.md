# 13章 短いコードを書く *Writing Less Code*
最も読みやすいコードは、何も書かれていないコードだ。

### 13.1 その機能の実装について悩まないで ―― きっと必要ないから *Don't Bother Implementing That Feature ―― You Won't Need It*
プロジェクトを開始するときには、これから実装するカッコいい機能のことを考えて興奮するものだ。そして、プロジェクトに欠かせない機能を過剰に見積もってしまう。その結果、多くの機能が、完成しないか、全く使われないか、アプリケーションを複雑にするものになってしまう。

プログラマというのは、実装にかかる労力を過小評価するものである。プロトタイプの実装にかかる時間を楽観的に見積ったり、将来的に必要となる保守や文書化などの「負担」時間を忘れたりする。

### 13.2 質問と要求の分割 *Question and Break Down Your Requirements*
すべてのプログラムが、高速で、100% 正しくて、あらゆる入力をうまく処理する必要はない。

要求を詳しく調べれば、問題をもっと簡単にできることもある。そうすれば、必要なコードも少なくて済む。このような例をいくつか見ていこう。

#### 例: 店舗検索システム *Example: A Store Locator*
「任意のユーザの緯度経度に対して、最も近い店舗を検索する。」

これを 100% ただしく実装するには、以下のことも考慮しなければいけない。

- 日付変更線をまたいでいるときの処理
- 北極や南極に近いときの処理
- 「 1 マイル当たりの」経度に対応した地球の曲率の調整

これらを真面目に処理すれば、相当な量のコードになる。でも、君のアプリケーションで扱うのは、テキサス州にある 30 軒の店舗だけだ。こんな小さな範囲で上記の 3 つの処理を考える必要はない。

「テキサス州のユーザのために、テキサスで最も近くにある店舗を検索する。」

この問題を解決するのは簡単だ。すべての店舗との距離を計算すればいい。

#### 例: キャッシュを追加する *Example: Adding a Cache*
ディスクから頻繁にオブジェクトを取得するアプリケーションを考える。アプリケーションの速度は、ディスクの読み取り速度によって制限されていた。ぼくたちは何らかのキャッシュを実装したいと思っていた。

```
read ObjectA
read ObjectA
read ObjectA
read ObjectB
read ObjectB
read ObjectC
read ObjectD
read ObjectD
```

同じオブジェクトでも何度もアクセスしているのがわかると思う。キャッシュは確実に有効だ。

この問題に直面した時には、LRU 方式のキャッシュを使おうと思っていた。でも、手持ちのライブラリがなかったので、自分たちで実装することにした。そのときはハッシュテーブルとたん方向リストの両方を使っていて、コードは全部で 100 行になった。

でも、アクセスが必ず順番に行われていることに気づいたので、LRU 方式のキャッシュではなく、単項目キャッシュ（one-item cache）を実装することにした。LRU 方式を使った時の 90% の効果があった。それにメモリ使用量も少なくなった。

「要求の削除」と「より単純な問題の解決」に利点があるというのは、何も大げさに言ってるわけじゃない。要求というのは、お互いに微妙に干渉してしまうものだ。問題を半分にすることで、1/4 のコーディング時間で済むこともあるくらいだ。

### 1.3 コードを小さく保つ *Keeping Your Codebase Small*
プロジェクトを始めるときには、ソースファイルは 1 つか 2 つしかない。素晴らしい。コードをコンパイルして実行するなんて簡単だ。変更もしやすい。関数やクラスをどこで定義しているかもすぐに思い出せる。

プロジェクトが進んでいくと、ファイルが増えていく。ディレクトリを分けてファイルを整理しなきゃいけなくなってくる。どの関数がどの関数を呼び出しているかよくわからなくなってくる。バグを見つけるのもだんだん面倒になっていく。

最終的には、いろんなディレクトリにファイルが散らばることになる。プロジェクトは巨大になって、すべてを把握できる人はだれもいなくなる。新しい機能を追加するのが苦痛になってくる。コードを扱うのが厄介になって楽しくなくなる。

あらゆる協調システムは成長する。それらを結び付ける複雑さはもっと速い速度で成長する。これは宇宙の自然法則だ。

つまり、プロジェクトが成長しても、**コードをできるだけ小さく軽量に維持するしかない**。

- 汎用的な「ユーティリティ」コードを作って、重複コードを削除する（「10章 無関係の会問題を抽出する」参照）。
- 未使用のコードや無用の機能を削除する。
- プロジェクトをサブプロジェクトに分割する。
- コードの「重量」を意識する。軽量で機敏にしておく。

#### 未使用のコードを削除する *Removing Unused Code*
園芸家は、植物が生き生きと成長し続けられるように枝を刈り込む。これと同じで、邪魔になっている未使用のコードを刈り込むのはいい考えだ。

コードを書いたら、削除したくはないものだ。コードというのは「実際の仕事」をあらわしたものだからだ。つまり、コードをさくじょすれば、そこに費やした時間を無駄にすることんいなる。そんなのどうでもいいんだよ！ ここはクリエイティブな分野だ。写真家・作家・映像制作者が、自分の作ったものすべて残しているだろうか。

独立した関数を削除するのは簡単だ。でも、「未使用のコード」は、気づかないうちにプロジェクト全体に深く絡み合っていることがある。

- 国際的なファイル名を扱うシステムをせっけいしたとする。そのコードは今でも変換コードに含まれている。でも、そのコードは一度も使われていない。アプリケーションが国際的なファイルを扱うことがないからだ。どうしてこの機能を削除しないのだろうか？
- メモリを使い果たしても動くようなシステムにしたかったので、メモリ不足からうまく回復するロジックをたくさんプログラムに組み込んだ。考え方は悪くなかったけど、実際にメモリ不足になると単なる不安定なゾンビになってしまう。必要な機能も使えない。ワンクリックで死亡だ。どうして「システムがメモリ不足です」と言ってプログラムを終了しないのだろうか？ どうしてメモリ不足の原因となっているコードを削除しないのだろうか？

### 13.4 身近なライブラリに親しむ *Be Familiar with the Libraries Around You*
プログラマというのは、既存のライブラリで問題を解決できることを知らないことが多い。あるいは、ライブラリで可能なことを忘れていることが多い。ライブラリの機能を熟知して、実際に活用することが大切だ。

ここでささやかな提案だ。**たまには標準ライブラリのすべての関数・モジュール・型の名前を 15 分かけて読んでみよう。**

ライブラリを全部覚えろと言っているわけじゃない。どんなことができそうか感じ取るだけでいい。そうすれば、新しいコードをかいているときに、「ちょっと待てよ。これは、API でみたような……」と思い出すことができる。

#### 例: リストとセット *Lists and Sets*
リストの要素から重複を取り除きたいとする。

でも、あまり知られていない Set 型を使った方がいい。

#### ライブラリの再利用はなぜいいことなのか *Why Reusing Libraries Is Such a Win*
よく使われる統計だけど、平均的なソフトウェアエンジニアが 1 日に書く出荷用のコードは、10 行なのだそうだ。

大切なのは、出荷用という言葉だ。成熟したライブラリのコードの裏側には、膨大な統計・デバッグ・修正・文書・最適化・テストが存在する。このダーウィンの進化を生き延びてきたコードには大きな価値がある。これがライブラリの再利用が良しとされている理由の 1 つだ。時間の節約になるし、書くコードも少なくなる。

### 13.5 例: コーディングするよりも　Unix ツールボックスを使う *Example: Using Unix Tools Instead of Coding*
ウェブサーバが頻繁に 4xx や 5xx の HTTP レスポンスコードを返していいたら、何かもんだいがあるという兆候だ。ウェブサーバのアクセスログをパースシテ、どの URL でエラーが発生しているかを調べたい。

4xx や 5xx のレスポンスコードをかえしている url-path を見つけるプログラムは、軽く 20 行を超えてしまう。一方 Unix では以下のコマンドを入力すればいい。

```
cat acces.log | awk '{ print $5 " " $7 }' | egrep "[45]..$" \ | sort | uniq -c | sort -nr 
```

コマンドラインが素晴らしいのは、「本物」のコードを書かなくてもいいことだ。それから、ソース管理にチェックインしなくても済む。

### 13.6 まとめ *Summary*
本章では、できるだけコードを書かないことについて説明した。新しいコードは、テストや文書や保守が必要になる。また、コードが増えると「重く」なるし、開発も難しくなる。

新しいコードを書かないようにするには

- 不必要な機能をプロダクトから削除する。過剰な機能は持たせない。
- もっとも簡単に問題を解決できるような要求を考える。
- 定期的にすべての API を読んで、標準ライブラリに慣れ親しんでおく。
